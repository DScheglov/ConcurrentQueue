# Альтернативне рішення для Конкурентної Асинхорнної черги

## Зауваження до Початкового Рішення

[Початкове рішення](../JavaScript/) переускладнено через порушення
принципу Єдиної Відповідальності. Так клас `Queue` вирішує одрузу декілька задач:

1. Власне організує виклики функції `onProcess` в чергу з урахуванням доступних потоків обробки, таймаутів очікування та приоритетів
2. Контролює таймаут виконання функції `onProcess`
3. Надає можливість спостерігати за процесом обробки черги
4. Надає інтерфейс для побудови Об'єкта Черги, емітуючи реалізацію паттерна проектування `Builder`

Окремо має сенс проговорити, контроль таймауту виконання функції `onProcess` на боці об'єкта черги. Не дивлячись на схожість цієї задачі із контролем таймаута перебування в черзі, поєднання її рішення з чергою не є зручним.

Справа в тому, що реалізація таймауту виконання функції `onProcess` дуже залежіть від того, що ця функція робить, і власне позаштатне завершення виконання функції `onProcess` може потребувати використання `abortController` (наприклад для відкату частково завершеної транзакції). В очевидь, об'єкт черги нічого не знаю про сутність функцію `onProcess`, то ж не може коректно ініціювати її завершення по таймауту.

У той же час, запропонована реалізація взагалі не завершує таке виконання, а лише генерує помилку та розповсюджеє відповідну подію підписнику.

## Ідея Альтернативного Рішення

Головна ідея полягає в тому, щоб вирішити згадані вище задачі окремо у вигляді декораторів асінхронної функції:

1. [Декоратор `queue`](./src/5-queue.factors.ts) - отрмиує на вхід функцію (аналог `onProcess`) та параметри для побудови черги її викликів. Декорована функція не змінює своєї сігнатури та має додаткови методи:
   1. `::pause()` | для зупинки обробки черги
   2. `::resume()` | для відновлення обробки черги
   3. `::stats()` | для надання інформації про чергу

2. [Декоратор `observeCalls`](./src/common/obseerve-calls.ts) - отримує на вхід асинхронну функцію та дозволяє підписатися на результати її виконання багатьом підписникам. Декорована функція не змінює своєї сігнатури та має додаткові методи:
   1. `::subscribe(listener)` | для підписки на результати виклику функції. Метод повертаю функцію для відписки
   2. `::unsubscribe(listener)` | для відписки від результатів виклику функції.

3. [Декоратор `observeQueue`](./src/6-queue.observable.ts) - отримує функцію декоравано `queue`, декорує її за допомогою `observeCalls` та додає методи для окремої підписки на події черги:
   1. `::onSuccess(successListener)`
   2. `::onFailure(failureListener)`
   3. `::onDone(doneListener)`
   4. `::onDrain(drainListener)`

Додатково функція, що емітує контроль таймаута виконання, реалізовна у вигляді [декоратора `timeout`](./src/common/timeout.ts).

## Інсталяція Альтерантивного Рішення

```shell
git clone https://github.com/DScheglov/ConcurrentQueue.git
cd alternative
```

```shell
npm install
```

## Запуск Прикладів

| shell | опис |
| :---- | :--- |
| `npm run sample:1-1` | найпростіша реалізація черги лише з конкурентністю <br>[код прикладу](src/1-queue.sample-1.ts), [код реалізації](src/1-queue.concurrency.ts) |
| `npm run sample:1-2` | та сама реалізація, але до прикладу додано логування <br>[код прикладу](src/1-queue.sample-2.ts), [код реалізації](src/1-queue.concurrency.ts) |
| `npm run sample:2` | до черги додано приорітети  <br>[код прикладу](src/2-queue.sample.ts), [код реалізації](src/2-queue.priorities.ts) |
| `npm run sample:3` | до черги додано стоп/пуск  <br>[код прикладу](src/3-queue.sample.ts), [код реалізації](src/3-queue.pause.ts) |
| `npm run sample:4` | до черги додано таймаут очікування  <br>[код прикладу](src/4-queue.sample.ts), [код реалізації](src/4-queue.timeouts.ts) |
| `npm run sample:5` | додано фактори для чередування викликів з різним фактором <br>[код прикладу](src/5-queue.sample.ts), [код реалізації](src/5-queue.factors.ts) |
| `npm run sample:6-1` | реалізовано спостореження за викликами функції. Приклад переносить журналювання до слухачів  <br>[код прикладу](src/6-queue.sample-1.ts), [код реалізації](src/6-queue.observable.ts) |
| `npm run sample:6-2` | приклад показує, як можна "запайпати" одну чергу у дві інших. <br>[код прикладу](src/6-queue.sample-1.ts), [код реалізації](src/6-queue.observable.ts) |
